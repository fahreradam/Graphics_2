#version 430
in vec2 v_texcoord;
in vec3 v_normal;
in vec3 v_worldpos;
in vec4 v_tangent;
in vec2 b_texcoord;

#define AMBIENT_UP vec3(0.1,0.1,0.1)
#define AMBIENT_DOWN vec3(0.2,0.2,0.2)



out vec4 color;
layout(binding=0) uniform sampler2DArray tex;
layout(binding=1) uniform sampler2DArray emittex;
layout(binding=2) uniform sampler2DArray bumpmapTexture;
layout(binding=3) uniform sampler2DArray metallicityRoughnessTexture;
layout(binding=7) uniform samplerCube envMap;
layout(binding=15) uniform sampler2DArray depthtex;


vec3 schlickFresnel(vec3 F0, float cos_phi, vec3 objectColor, float metallicity){
    vec3 one_minus_F0 = vec3(1.0)-F0;
    return F0 + one_minus_F0 * pow(1.0 - cos_phi,5.0);
}

vec3 schlickDiffuse( vec3 F, float cos_phi,
        float mu, vec3 baseColor,
        float cos_theta_i )
{
    vec3 d = mix( 0.96*baseColor , vec3(0), mu );
    //might want to divide by pi here
    return cos_theta_i * ( vec3(1.0)-F) * d ;
}

vec3 schlickSpecular( vec3 F, float cos_phi, float cos_psi,
        vec3 baseColor, float cos_theta_i,
        float cos_theta_o, float rho, float mu)
{
    float rho2 = rho*rho;

    float disc1 = max(0.0,
            rho2 + (1.0-rho2) * cos_theta_o * cos_theta_o );
    float disc2 = max(0.0,
            rho2 + (1.0-rho2) * cos_theta_i * cos_theta_i );
    float denom = max(0.0001,
            cos_theta_i * sqrt( disc1 ) +
            cos_theta_o * sqrt( disc2 )
    );

    float V = 1.0 / (2.0 * denom );
    float tmp = rho / (1.0 + cos_psi*cos_psi * (rho2-1.0) );
    float D = 1.0/3.14 * tmp*tmp;
    return cos_theta_i * F * V * D;
}


void main(){
    if(forceColorFlag != 0.0)
    {
    color = forceColor;
    return;
    }
    if( testDepth != 0.0 ){
        float d = texelFetch( depthtex,
                ivec3(gl_FragCoord.xy,0), 0 ).r;
        if( gl_FragCoord.z < d ){
            discard;
            return;
        }
    }



    vec3 N = normalize(v_normal);


    vec4 b = texture( bumpmapTexture, vec3(b_texcoord,0.0) );

    vec4 metallicityRoughness = texture(
                                        metallicityRoughnessTexture,
                                        vec3(v_texcoord,0.0));

    float metallicity = texture(metallicityRoughnessTexture, vec3(v_texcoord, 0.0)).b;
    vec3 V = normalize( eyePos - v_worldpos);
    vec3 VR = reflect(-V, N);




    if( v_tangent.w != 0.0 ){
        vec3 T = v_tangent.xyz;
        T = T-dot(T,N) * N;
        T = normalize(T);
        vec3 B = cross(N,T);

        B = normalize(B);

        mat3 M = mat3(T.x, B.x, N.x,
                      T.y, B.y, N.y,
                      T.z, B.z, N.z);

        vec3 beta = (2.0 * (b.rgb - vec3(0.5)));
        N = beta * M;


    }
    N = (vec4(N,0.0) * worldMatrix).xyz;
    N = normalize(N);

    //surface normal
    //vec3 N = normalize(v_normal);
    
    //vector from surface to viewer

    vec3 ambient = mix( AMBIENT_DOWN, AMBIENT_UP, 0.5*(N.y+1.0));

    color = texture(tex, vec3(v_texcoord, 0.0));
    vec3 totaldiffuse = vec3(0);
    vec3 totalspecular = vec3(0);
    
    for(int i=0;i<MAX_LIGHTS;++i){
        
        //unpack data from uniforms
        vec3 lightPosition = lightPositionsAndDirectionalFlag[i].xyz;
        float positionalOrDirectional = lightPositionsAndDirectionalFlag[i].w;
        vec3 spotDirection = spotDirectionsAndCosineSpotEdgeStarts[i].xyz;
        float cosineSpotEdgeStart = spotDirectionsAndCosineSpotEdgeStarts[i].w;
        vec3 lightColor = lightColorsAndCosineSpotAngleCutoffs[i].xyz;
        float cosineSpotAngleCutoff = lightColorsAndCosineSpotAngleCutoffs[i].w;
        
        //vector from surface to light
        vec3 L = lightPosition - v_worldpos;
        float lightDistance = length(L);
        L /= lightDistance;

        //reflection vector of light
        vec3 R = reflect(-L,N);

        vec3 H = L+V;
        H = normalize(H);
        float mu = metallicityRoughness.b;
        vec3 F0 = mix( vec3(0.04), color.rgb, mu );
        float cos_phi = max(0, dot(V,H));
        float cos_psi = max(0, dot(N,H));
        float cos_theta_i = max(0, dot(N,L));
        float cos_theta_o = max(0, dot(N,V));
        float rho = metallicityRoughness.g;

        vec3 F = schlickFresnel(F0, cos_phi, color.rgb, mu);
        vec3 diffuse = schlickDiffuse(F, cos_phi, mu, color.rgb, cos_theta_i);
        vec3 specular = schlickSpecular(F, cos_phi, cos_psi, color.rgb, cos_theta_i, cos_theta_o, rho, mu);


        //attenuation
        float A = 1.0/(attenuation[0] + lightDistance*(attenuation[1] + lightDistance*attenuation[2]));
        A=min(A,1.0);
        diffuse *= A;
        specular *= A;
        
        //spotlight cutoff
        float cosineTheta = dot(-L,spotDirection);
        float spotAttenuation = smoothstep( 
                        cosineSpotAngleCutoff, 
                        cosineSpotEdgeStart, 
                        cosineTheta);
        diffuse *= spotAttenuation;
        specular *= spotAttenuation;
        
        
        //add to running total
        totaldiffuse += diffuse*lightColor;
        totalspecular += specular*lightColor;
    }



   
    //combine texture + emission
    vec3 texcoord = vec3(v_texcoord, animationFrame);
    vec4 texc = texture( tex, texcoord );
    vec3 etexc = texture( emittex, texcoord).rgb;
    if( any( notEqual(etexc,vec3(0.0))))
        color.rgb = etexc;
    else
        color.rgb = (ambient+totaldiffuse)*texc.rgb + totalspecular;
    color.a = texc.a * alphaFactor;

    vec3 reflColor = texture(envMap, VR, metallicityRoughness.g * 25).rgb;
    color.rgb += (1-metallicityRoughness.g) * metallicityRoughness.b * reflColor.rgb;

}
